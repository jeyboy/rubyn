#include "rubydoc_parser.h"

#include "tools/thread_utils.h"
#include "tools/html/html_page.h"

#include "controls/logger.h"

#include <qdiriterator.h>

bool RubydocParser::parseFile(const QString & inpath, const QString & outpath) {
    QByteArray description_prefix("# ");
    QByteArray description_example_prefix("#     ");
    QByteArray target_prefix("    ");

// title text -> split : -> take first

// #method-list-section li a text

// #parent-class-section p text

// #includes-section li a text

// #documentation
//
//      #constants-list
//          dt a text // name
//          dd p text // description

//      .method-section#public-class-method-details
//      .method-section#public-instance-method-details
//      .method-section#private-instance-method-details

//          .method-detail
//              .method-heading .method-callseq text

    QFile datafile(inpath);

    if (datafile.open(QFile::ReadOnly | QFile::Text)) {
        QFile outfile(outpath);

        if (outfile.open(QFile::WriteOnly | QFile::Text)) {
            QTextStream out(&outfile);

            out << "# encoding: UTF-8";
            out << "# GENERATED BY FUKC @JB";

            Html::Page page(&datafile, Html::Decoding::charset_utf8, Html::Page::pf_skip_comment);

            Html::Tag * metadata_block = page.findFirst("#metadata");

            if (!metadata_block) {
                Logger::obj().write(QLatin1Literal("RubydocParser"), QLatin1Literal("Cant parse metadata block in file: ") % inpath);
                datafile.close(); out.flush(); outfile.close();
                return false;
            }

            Html::Tag * doc_block = page.findFirst("#documentation");

            if (!doc_block) {
                Logger::obj().write(QLatin1Literal("RubydocParser"), QLatin1Literal("Cant parse documentation block in file: ") % inpath);
                datafile.close(); out.flush(); outfile.close();
                return false;
            }

            Html::Tag * doc_header = doc_block -> findFirst("h1");

            if (!doc_header) {
                Logger::obj().write(QLatin1Literal("RubydocParser"), QLatin1Literal("Cant parse doc header in file: ") % inpath);
                datafile.close(); out.flush(); outfile.close();
                return false;
            }

            Html::Tag * doc_description = doc_block -> findFirst("#description");

            if (!doc_description) {
                Logger::obj().write(QLatin1Literal("RubydocParser"), QLatin1Literal("Cant parse doc description in file: ") % inpath);
                datafile.close(); out.flush(); outfile.close();
                return false;
            }

            Html::Set descrition_parts = doc_description -> children();

            for(Html::Set::Iterator tag = descrition_parts.begin(); tag != descrition_parts.end(); tag++) {
                switch((*tag) -> tagID()) {
                    case Html::Tag::tg_p: {
                        writeLine(description_prefix, QString((*tag) -> texts()), &out);
                    break;}

                    case Html::Tag::tg_h2: {
                        QByteArray border((*tag) -> text().length(), '-');

                        out
                            << endl
                            << border
                            << endl
                            << description_prefix
                            << (*tag) -> text()
                            << border
                            << endl;
                    break;}

                    case Html::Tag::tg_pre: {
                        out
                            << description_prefix
                            << "-- EXAMPLE --"
                            << endl << description_example_prefix;

                        Html::Set code_parts = (*tag) -> children();

                        for(Html::Set::Iterator code_tag = code_parts.begin(); code_tag != code_parts.end(); code_tag++) {
                            if ((*code_tag) -> isNewline())
                                out << endl << description_example_prefix;
                            else
                                out << QString((*code_tag) -> text());
                        }
                    break;}

                    default: {
                        Logger::obj().write(
                            QLatin1Literal("RubydocParser"),
                            QLatin1Literal("Unknown tag type in description: ") % (*tag) -> name() %
                                QLatin1Literal("  in file: ") % inpath
                        );
                    }
                }
            }


            QByteArray target_class = doc_header -> rawClasses();
            QByteArray target_name = doc_header -> text();
            QByteArray parent_name;

            Html::Tag * parent_tag = metadata_block -> findFirst("#parent-class-section p a");

            if (parent_tag)
                parent_name = parent_tag -> text();


            /////////////////// REMOVE ME LATER
            if (target_class != "class" && target_class != "module") {
                Logger::obj().write(QLatin1Literal("RubydocParser"), QLatin1Literal("New target type: ") % target_class % QLatin1Literal("  in file: ") % inpath);
            }
            //////////////////////////////////////

            out << target_class << ' ' << target_name;

            if (!parent_name.isEmpty())
                out << " < " << parent_name;

            out << endl;


            Html::Set includes_texts = metadata_block -> find("#includes-section li a text");

            if (!includes_texts.isEmpty()) {
                for(Html::Set::Iterator include_tag = includes_texts.begin(); include_tag != includes_texts.end(); include_tag++) {
                    out << target_prefix << "include " << QString((*include_tag) -> text());
                }
            }

            Html::Set sections = doc_block -> find(".section");

            QByteArray constants_section("constants-list");

            QByteArray public_class_methods_section("public-class-method-details");
            QByteArray public_instance_methods_section("public-instance-method-details");

//            QByteArray private_class_methods_section("private-class-method-details"); // ???
            QByteArray private_instance_methods_section("private-instance-method-details");

            QByteArray methods_prefix;

            for(Html::Set::Iterator section_tag = sections.begin(); section_tag != sections.end(); section_tag++) {
                const QByteArray & id = (*section_tag) -> id();

                if (id == constants_section) {
                    Html::Tag * list_tag = (*section_tag) -> findFirst("dl");

                    if (list_tag -> hasChildren()) {
                        Html::Set constants = list_tag -> children();

                        for(Html::Set::Iterator const_tag = constants.begin(); const_tag != constants.end(); const_tag++) {
                            out << target_prefix << ((*const_tag) -> text()) << " # " << ((*++const_tag) -> text()) << endl;
                        }
                    }
                } else {
                    if (id == public_class_methods_section) {
                        methods_prefix = QByteArray("public def self.");
                    } else if (id == public_instance_methods_section) {
                        methods_prefix = QByteArray("public def ");
                    } else if (id == private_instance_methods_section) {
                        methods_prefix = QByteArray("private def ");
                    }

                    Html::Set methods = (*section_tag) -> find(".method-detail");

                    for(Html::Set::Iterator method_tag = methods.begin(); method_tag != methods.end(); method_tag++) {
                        Html::Set divs = (*method_tag) -> find("> div");

                        QByteArray signature = divs[0] -> findFirst(".method-heading .method-callseq") -> text();

                        out << target_prefix << methods_prefix << signature << endl << endl << "end" << endl;

                        Html::Set method_descriptions = divs[1] -> children();

                        for(Html::Set::Iterator tag = method_descriptions.begin(); tag != method_descriptions.end(); tag++) {
                            switch((*tag) -> tagID()) {
                                case Html::Tag::tg_p: {
                                    writeLine(target_prefix, QString((*tag) -> texts()), &out);
                                break;}

                                case Html::Tag::tg_pre: {
                                    out
                                        << endl << target_prefix << description_example_prefix;

                                    Html::Set code_parts = (*tag) -> children();

                                    for(Html::Set::Iterator code_tag = code_parts.begin(); code_tag != code_parts.end(); code_tag++) {
                                        if ((*code_tag) -> isNewline())
                                            out << endl << target_prefix << description_example_prefix;
                                        else
                                            out << QString((*code_tag) -> text());
                                    }
                                break;}

                                default: {
                                    Logger::obj().write(
                                        QLatin1Literal("RubydocParser"),
                                        QLatin1Literal("Unknown tag type in method description: ") % (*tag) -> name() %
                                            QLatin1Literal("  in file: ") % inpath
                                    );
                                }
                            }
                        }
                    }
                }
            }

            out.flush();
            outfile.close();
        } else {
            Logger::obj().write(QLatin1Literal("RubydocParser"), QLatin1Literal("Cant open output file: ") % inpath);
            datafile.close();
            return false;
        }

        datafile.close();
    } else {
        Logger::obj().write(QLatin1Literal("RubydocParser"), QLatin1Literal("Cant open file: ") % inpath);
        return false;
    }

    return true;
}

bool RubydocParser::parseFolder(const QString & path, const QString & outpath) {
    QDirIterator files_it(path, QDir::Files | QDir::Hidden, QDirIterator::Subdirectories);

    while(files_it.hasNext()) {
        QString path = files_it.next();
        QString dir_name = files_it.fileName();

        if (dir_name[0].isUpper()) {
            parseFile(path, outpath);
        }
    }

    return true;
}

void RubydocParser::writeLine(const QByteArray & prefix, const QString & datum, QTextStream * out, const uint & max_line_len) {
    uint pos = 0;

    while(true) {
        QStringRef line = datum.midRef(pos, max_line_len + 1);

        if (line.isEmpty())
            break;

        if (!line.back().isSpace()) {
            int line_size = line.length();

            for(; line_size >= 0; --line_size) {
                if (line[line_size - 1].isSpace())
                    break;
            }

            line = line.mid(0, line_size - 1);
        }

        (*out) << prefix << line << endl;

        pos += line.length();
    }
}

RubydocParser::RubydocParser(QObject * parent) : QObject(parent) {
//    ThreadUtils::obj().run(
//        this, &FilesProcManager::cleanerProc,
//        new Func()
//    );
}

bool RubydocParser::parse(const QString & inpath, const QString & outpath) {


    return true;
}
